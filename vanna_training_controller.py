#!/usr/bin/env python3
"""
Script de Controle de Training Data - Modelo Vanna
Fun√ß√µes: Backup, Remo√ß√£o, Listagem e Restaura√ß√£o de dados de treinamento

üîß FUNCIONALIDADES:
- ‚úÖ Backup de dados de treinamento (JSON + PostgreSQL)
- ‚úÖ Remo√ß√£o segura de todos os dados
- ‚úÖ Restaura√ß√£o de backups
- ‚úÖ Listagem detalhada de dados
- ‚úÖ Listagem de backups dispon√≠veis

üöÄ EXEMPLOS DE USO:
# Listar dados atuais
python vanna_training_controller.py list

# Fazer backup completo
python vanna_training_controller.py backup --backup-type both

# Fazer backup para cliente espec√≠fico
python vanna_training_controller.py backup --client-id cliente_001 --backup-type postgresql

# Remover todos os dados (CUIDADO!)
python vanna_training_controller.py remove --confirm

# Restaurar do PostgreSQL
python vanna_training_controller.py restore --client-id cliente_001

# Restaurar de arquivo JSON
python vanna_training_controller.py restore --backup-path backups/backup_training_global_20250123_143052.json

# Listar backups dispon√≠veis
python vanna_training_controller.py list-backups

# Ver status completo do sistema
python vanna_training_controller.py status

# Sincronizar dados Vanna ‚Üí PostgreSQL
python vanna_training_controller.py sync --direction vanna_to_postgresql --client-id cliente_001

# Sincronizar dados PostgreSQL ‚Üí Vanna
python vanna_training_controller.py sync --direction postgresql_to_vanna --client-id cliente_001

# Comparar dados entre Vanna e PostgreSQL
python vanna_training_controller.py compare --client-id cliente_001

üìã CONFIGURA√á√ÉO:
- Crie arquivo .env com as vari√°veis: API_KEY, DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD
- Instale depend√™ncias: pip install vanna python-dotenv psycopg2-binary pandas

Baseado no padr√£o estabelecido em flaskVanna.py
Integrado com migra√ß√£o PostgreSQL via DatabaseManager
"""

import os
import sys
import json
import logging
from datetime import datetime
from dotenv import load_dotenv
from vanna.remote import VannaDefault

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO, 
    format="%(asctime)s - VANNA_CONTROL - %(levelname)s - %(message)s"
)

# Adicionar src ao path para importar database_manager
src_path = os.path.abspath(os.path.join(os.path.dirname(__file__), 'src'))
if src_path not in sys.path:
    sys.path.append(src_path)

try:
    from database_manager import db_manager
    print("‚úÖ DatabaseManager importado com sucesso")
    DB_AVAILABLE = True
except ImportError as e:
    print(f"‚ö†Ô∏è DatabaseManager n√£o dispon√≠vel: {e}")
    DB_AVAILABLE = False

class VannaTrainingController:
    """
    Controlador para gerenciamento de training_data do modelo Vanna
    Integrado com PostgreSQL e backup JSON
    """
    
    def __init__(self):
        """Inicializa o controlador carregando configura√ß√µes"""
        logging.info("üöÄ Inicializando Vanna Training Controller...")
        
        # Carregar vari√°veis de ambiente
        load_dotenv(override=True)
        logging.info("üìã Vari√°veis de ambiente carregadas")
        
        # Configura√ß√µes do banco
        self.db_config = {
            'host': os.getenv("DB_HOST"),
            'port': os.getenv("DB_PORT"),
            'dbname': os.getenv("DB_NAME"),
            'user': os.getenv("DB_USER"),
            'password': os.getenv("DB_PASSWORD")
        }
        
        # API Key da Vanna
        self.api_key = os.getenv("API_KEY")
        
        # Valida√ß√µes
        if not self.api_key:
            raise ValueError("API_KEY deve estar definida no .env")
        
        if not all([self.db_config['host'], self.db_config['user'], self.db_config['password']]):
            logging.warning("‚ö†Ô∏è Configura√ß√µes do banco incompletas - alguns recursos podem n√£o funcionar")
        
        # Inicializar Vanna
        self.vn = None
        self._connect_vanna()
        
        # Diret√≥rios para backup
        self.backup_dir = os.path.join(os.path.dirname(__file__), "backups")
        os.makedirs(self.backup_dir, exist_ok=True)
        
        logging.info("‚úÖ Vanna Training Controller inicializado com sucesso")
    
    def _connect_vanna(self):
        """Conecta ao modelo Vanna e banco PostgreSQL"""
        try:
            logging.info("üîå Conectando ao modelo Vanna...")
            self.vn = VannaDefault(model="jarves", api_key=self.api_key)
            
            # Conectar ao PostgreSQL
            response = self.vn.connect_to_postgres(**self.db_config)
            logging.info(f"‚úÖ Conex√£o estabelecida: {response}")
            
        except Exception as e:
            logging.error(f"‚ùå Erro ao conectar Vanna: {e}")
            raise
    
    def listar_training_data(self, show_details=True):
        """
        Lista todos os dados de treinamento do modelo Vanna
        
        Args:
            show_details (bool): Se deve mostrar detalhes dos dados
            
        Returns:
            pandas.DataFrame: Dados de treinamento
        """
        logging.info("üìã Listando dados de treinamento...")
        
        try:
            training_data = self.vn.get_training_data()
            
            if training_data is None or training_data.empty:
                logging.info("‚ÑπÔ∏è Nenhum dado de treinamento encontrado no modelo")
                return None
            
            total_records = len(training_data)
            logging.info(f"üìä Total de registros encontrados: {total_records}")
            
            if show_details:
                # Mostrar estat√≠sticas por tipo
                if 'training_data_type' in training_data.columns:
                    tipos = training_data['training_data_type'].value_counts()
                    logging.info("üìà Distribui√ß√£o por tipo:")
                    for tipo, count in tipos.items():
                        logging.info(f"   - {tipo}: {count} registros")
                
                # Mostrar algumas amostras
                logging.info("üîç Primeiros 3 registros:")
                for i, row in training_data.head(3).iterrows():
                    logging.info(f"   [{i}] ID: {row.get('id', 'N/A')}")
                    logging.info(f"       Tipo: {row.get('training_data_type', 'N/A')}")
                    if 'question' in row and row['question']:
                        logging.info(f"       Pergunta: {str(row['question'])[:50]}...")
                    if 'content' in row:
                        logging.info(f"       Conte√∫do: {str(row['content'])[:50]}...")
                    logging.info("       ---")
            
            return training_data
            
        except Exception as e:
            logging.error(f"‚ùå Erro ao listar training data: {e}")
            return None
    
    def realizar_backup(self, client_id=None, backup_type="both"):
        """
        Realiza backup dos dados de treinamento
        
        Args:
            client_id (str, optional): ID do cliente (None = backup global)
            backup_type (str): Tipo de backup - "json", "postgresql", "both"
            
        Returns:
            dict: Resultado do backup com paths e estat√≠sticas
        """
        logging.info(f"üíæ Iniciando backup (tipo: {backup_type}, cliente: {client_id or 'global'})...")
        
        resultado = {
            "success": False,
            "timestamp": datetime.now().isoformat(),
            "client_id": client_id,
            "backup_type": backup_type,
            "records_count": 0,
            "json_path": None,
            "postgresql_success": False,
            "errors": []
        }
        
        try:
            # Obter dados do modelo Vanna
            training_data = self.vn.get_training_data()
            
            if training_data is None or training_data.empty:
                logging.warning("‚ö†Ô∏è Nenhum dado encontrado para backup")
                resultado["errors"].append("Nenhum dado encontrado no modelo")
                return resultado
            
            # Converter para dict
            training_data_dict = training_data.to_dict(orient="records")
            resultado["records_count"] = len(training_data_dict)
            
            logging.info(f"üìã {len(training_data_dict)} registros obtidos do modelo")
            
            # Backup JSON
            if backup_type in ["json", "both"]:
                json_success, json_path = self._backup_to_json(training_data_dict, client_id)
                resultado["json_path"] = json_path
                if not json_success:
                    resultado["errors"].append("Falha no backup JSON")
            
            # Backup PostgreSQL
            if backup_type in ["postgresql", "both"] and DB_AVAILABLE:
                pg_success = self._backup_to_postgresql(training_data_dict, client_id)
                resultado["postgresql_success"] = pg_success
                if not pg_success:
                    resultado["errors"].append("Falha no backup PostgreSQL")
            elif backup_type in ["postgresql", "both"]:
                resultado["errors"].append("PostgreSQL n√£o dispon√≠vel")
            
            # Determinar sucesso geral
            if backup_type == "json":
                resultado["success"] = resultado["json_path"] is not None
            elif backup_type == "postgresql":
                resultado["success"] = resultado["postgresql_success"]
            else:  # both
                resultado["success"] = (resultado["json_path"] is not None or 
                                      resultado["postgresql_success"])
            
            if resultado["success"]:
                logging.info("‚úÖ Backup conclu√≠do com sucesso!")
            else:
                logging.error("‚ùå Backup falhou")
            
            return resultado
            
        except Exception as e:
            logging.error(f"‚ùå Erro durante backup: {e}")
            resultado["errors"].append(str(e))
            return resultado
    
    def _backup_to_json(self, training_data_dict, client_id):
        """Realiza backup para arquivo JSON"""
        try:
            # Nome do arquivo com timestamp
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            if client_id:
                filename = f"backup_training_client_{client_id}_{timestamp}.json"
            else:
                filename = f"backup_training_global_{timestamp}.json"
            
            backup_path = os.path.join(self.backup_dir, filename)
            
            # Adicionar metadados ao backup
            backup_data = {
                "metadata": {
                    "timestamp": datetime.now().isoformat(),
                    "client_id": client_id,
                    "records_count": len(training_data_dict),
                    "backup_type": "vanna_training_data"
                },
                "training_data": training_data_dict
            }
            
            # Salvar arquivo
            with open(backup_path, "w", encoding="utf-8") as f:
                json.dump(backup_data, f, indent=2, ensure_ascii=False)
            
            logging.info(f"‚úÖ Backup JSON salvo: {backup_path}")
            return True, backup_path
            
        except Exception as e:
            logging.error(f"‚ùå Erro no backup JSON: {e}")
            return False, None
    
    def _backup_to_postgresql(self, training_data_dict, client_id):
        """Realiza backup para PostgreSQL usando DatabaseManager"""
        try:
            # Usar helper para formata√ß√£o consistente
            formatted_data = db_manager.format_training_data_batch(training_data_dict, client_id or "global")
            
            # Salvar no PostgreSQL
            success = db_manager.save_training_data(client_id, formatted_data)
            
            if success:
                logging.info(f"‚úÖ Backup PostgreSQL salvo: {len(formatted_data)} registros")
                logging.info("‚úî Dados salvos no PostgreSQL")
                return True
            else:
                logging.error("‚ùå Falha ao salvar backup no PostgreSQL")
                return False
                
        except Exception as e:
            logging.error(f"‚ùå Erro no backup PostgreSQL: {e}")
            return False
    
    def remover_todos_training_data(self, confirm=False):
        """
        Remove todos os dados de treinamento do modelo Vanna
        
        Args:
            confirm (bool): Confirma√ß√£o de seguran√ßa
            
        Returns:
            dict: Resultado da opera√ß√£o
        """
        if not confirm:
            logging.warning("‚ö†Ô∏è ATEN√á√ÉO: Esta opera√ß√£o remove TODOS os dados de treinamento!")
            logging.warning("‚ö†Ô∏è Execute novamente com confirm=True para confirmar")
            return {"success": False, "message": "Opera√ß√£o n√£o confirmada"}
        
        logging.info("üóëÔ∏è INICIANDO REMO√á√ÉO DE TODOS OS DADOS DE TREINAMENTO...")
        
        resultado = {
            "success": False,
            "total_found": 0,
            "removed_count": 0,
            "failed_count": 0,
            "errors": []
        }
        
        try:
            # Obter todos os dados
            training_data = self.vn.get_training_data()
            
            if training_data is None or training_data.empty:
                logging.info("‚ÑπÔ∏è Nenhum dado encontrado para remover")
                resultado["success"] = True
                return resultado
            
            # Extrair IDs para remo√ß√£o
            ids = self._extract_ids_from_training_data(training_data)
            resultado["total_found"] = len(ids)
            
            logging.info(f"üéØ {len(ids)} registros encontrados para remo√ß√£o")
            
            # Remover cada item
            for i, item_id in enumerate(ids, 1):
                try:
                    self.vn.remove_training_data(id=item_id)
                    resultado["removed_count"] += 1
                    logging.info(f"‚úÖ [{i}/{len(ids)}] Removido: {item_id}")
                    
                except Exception as e:
                    resultado["failed_count"] += 1
                    error_msg = f"Erro ao remover {item_id}: {e}"
                    resultado["errors"].append(error_msg)
                    logging.error(f"‚ùå [{i}/{len(ids)}] {error_msg}")
            
            # Verificar resultado
            if resultado["removed_count"] == resultado["total_found"]:
                resultado["success"] = True
                logging.info(f"‚úÖ REMO√á√ÉO CONCLU√çDA: {resultado['removed_count']} registros removidos")
            else:
                logging.warning(f"‚ö†Ô∏è REMO√á√ÉO PARCIAL: {resultado['removed_count']}/{resultado['total_found']} removidos")
            
            return resultado
            
        except Exception as e:
            logging.error(f"‚ùå Erro durante remo√ß√£o: {e}")
            resultado["errors"].append(str(e))
            return resultado
    
    def _extract_ids_from_training_data(self, training_data):
        """Extrai IDs dos dados de treinamento (baseado no c√≥digo do flaskVanna)"""
        try:
            # M√©todo principal: DataFrame com coluna 'id'
            ids = training_data["id"].tolist()
            return ids
            
        except (AttributeError, KeyError, TypeError):
            # Fallbacks para outros formatos
            logging.warning("‚ö†Ô∏è Usando fallback para extra√ß√£o de IDs")
            
            if isinstance(training_data, list):
                if training_data and isinstance(training_data[0], dict):
                    ids = [item["id"] for item in training_data if "id" in item]
                else:
                    ids = list(training_data)
            elif isinstance(training_data, dict):
                ids = [training_data["id"]] if "id" in training_data else []
            else:
                ids = []
            
            return ids
    
    def restaurar_backup(self, backup_path=None, client_id=None):
        """
        Restaura dados de treinamento a partir de backup
        
        Args:
            backup_path (str): Caminho para arquivo de backup JSON
            client_id (str): ID do cliente (para backup PostgreSQL)
            
        Returns:
            dict: Resultado da restaura√ß√£o
        """
        logging.info("üîÑ Iniciando restaura√ß√£o de backup...")
        
        resultado = {
            "success": False,
            "source": None,
            "records_loaded": 0,
            "trained_count": 0,
            "errors": []
        }
        
        try:
            training_data = None
            
            # Restaurar do arquivo JSON
            if backup_path:
                training_data = self._load_from_json_backup(backup_path)
                resultado["source"] = f"JSON: {backup_path}"
            
            # Restaurar do PostgreSQL
            elif client_id is not None and DB_AVAILABLE:
                training_data = db_manager.load_training_data(client_id)
                resultado["source"] = f"PostgreSQL: cliente {client_id}"
            
            # Restaurar de backup global PostgreSQL
            elif DB_AVAILABLE:
                training_data = db_manager.load_training_data(None)  # Dados globais
                resultado["source"] = "PostgreSQL: backup global"
            
            else:
                resultado["errors"].append("Nenhuma fonte de backup especificada ou dispon√≠vel")
                return resultado
            
            if not training_data:
                resultado["errors"].append("Nenhum dado encontrado na fonte de backup")
                return resultado
            
            resultado["records_loaded"] = len(training_data)
            logging.info(f"üìã {len(training_data)} registros carregados de {resultado['source']}")
            
            # Aplicar treinamento no modelo Vanna
            for item in training_data:
                try:
                    tipo = item.get("training_data_type", "").lower()
                    conteudo = item.get("content", "").strip()
                    pergunta = item.get("question", "").strip()
                    
                    if not conteudo:
                        continue
                    
                    if tipo == "ddl":
                        self.vn.train(ddl=conteudo)
                        resultado["trained_count"] += 1
                    elif tipo == "sql" and pergunta:
                        self.vn.train(sql=conteudo, question=pergunta)
                        resultado["trained_count"] += 1
                    elif tipo == "documentation":
                        self.vn.train(documentation=conteudo)
                        resultado["trained_count"] += 1
                    
                except Exception as e:
                    error_msg = f"Erro ao treinar item {item.get('id', 'N/A')}: {e}"
                    resultado["errors"].append(error_msg)
                    logging.error(f"‚ùå {error_msg}")
            
            resultado["success"] = resultado["trained_count"] > 0
            
            if resultado["success"]:
                logging.info(f"‚úÖ Restaura√ß√£o conclu√≠da: {resultado['trained_count']} itens treinados")
                logging.info("‚úî Dados carregados e aplicados ao modelo")
            else:
                logging.warning("‚ö†Ô∏è Nenhum item foi treinado com sucesso")
            
            return resultado
            
        except Exception as e:
            logging.error(f"‚ùå Erro durante restaura√ß√£o: {e}")
            resultado["errors"].append(str(e))
            return resultado
    
    def _load_from_json_backup(self, backup_path):
        """Carrega dados de backup JSON"""
        try:
            with open(backup_path, "r", encoding="utf-8") as f:
                backup_data = json.load(f)
            
            # Verificar formato do backup
            if "training_data" in backup_data:
                return backup_data["training_data"]
            elif isinstance(backup_data, list):
                return backup_data
            else:
                raise ValueError("Formato de backup n√£o reconhecido")
                
        except Exception as e:
            logging.error(f"‚ùå Erro ao carregar backup JSON: {e}")
            return None
    
    def listar_backups(self):
        """Lista todos os backups dispon√≠veis"""
        logging.info("üìÅ Listando backups dispon√≠veis...")
        
        backups = {
            "json_backups": [],
            "postgresql_clients": []
        }
        
        # Backups JSON
        try:
            if os.path.exists(self.backup_dir):
                for filename in os.listdir(self.backup_dir):
                    if filename.endswith('.json') and 'backup_training' in filename:
                        filepath = os.path.join(self.backup_dir, filename)
                        stat = os.stat(filepath)
                        
                        backups["json_backups"].append({
                            "filename": filename,
                            "path": filepath,
                            "size_mb": round(stat.st_size / (1024*1024), 2),
                            "modified": datetime.fromtimestamp(stat.st_mtime).isoformat()
                        })
                
                logging.info(f"üìÑ {len(backups['json_backups'])} backups JSON encontrados")
        except Exception as e:
            logging.error(f"‚ùå Erro ao listar backups JSON: {e}")
        
        # Backups PostgreSQL
        if DB_AVAILABLE:
            try:
                # Listar clientes com dados
                clients = db_manager.get_training_data_ids(None)  # M√©todo para listar todos os clientes
                backups["postgresql_clients"] = list(set([id.split('-')[0] for id in clients if '-' in id]))
                logging.info(f"üóÑÔ∏è {len(backups['postgresql_clients'])} clientes com dados no PostgreSQL")
            except Exception as e:
                logging.error(f"‚ùå Erro ao listar backups PostgreSQL: {e}")
        
        return backups
    
    def sincronizar_dados(self, direcao="vanna_to_postgresql", client_id=None):
        """
        Sincroniza dados entre modelo Vanna e PostgreSQL
        
        Args:
            direcao (str): "vanna_to_postgresql" ou "postgresql_to_vanna"
            client_id (str): ID do cliente (para PostgreSQL)
        
        Returns:
            dict: Resultado da sincroniza√ß√£o
        """
        logging.info(f"üîÑ Iniciando sincroniza√ß√£o: {direcao}")
        
        resultado = {
            "success": False,
            "direction": direcao,
            "client_id": client_id,
            "source_count": 0,
            "target_count": 0,
            "synced_count": 0,
            "errors": []
        }
        
        try:
            if direcao == "vanna_to_postgresql":
                # Vanna ‚Üí PostgreSQL
                vanna_data = self.vn.get_training_data()
                
                if vanna_data is None or vanna_data.empty:
                    logging.info("‚ÑπÔ∏è Nenhum dado no modelo Vanna para sincronizar")
                    resultado["source_count"] = 0
                    resultado["success"] = True
                    return resultado
                
                vanna_data_dict = vanna_data.to_dict(orient="records")
                resultado["source_count"] = len(vanna_data_dict)
                
                # Salvar no PostgreSQL
                if DB_AVAILABLE:
                    success = db_manager.save_training_data(client_id, vanna_data_dict)
                    if success:
                        resultado["synced_count"] = len(vanna_data_dict)
                        resultado["success"] = True
                        logging.info(f"‚úÖ {len(vanna_data_dict)} registros sincronizados: Vanna ‚Üí PostgreSQL")
                    else:
                        resultado["errors"].append("Falha ao salvar no PostgreSQL")
                else:
                    resultado["errors"].append("PostgreSQL n√£o dispon√≠vel")
            
            elif direcao == "postgresql_to_vanna":
                # PostgreSQL ‚Üí Vanna
                if not DB_AVAILABLE:
                    resultado["errors"].append("PostgreSQL n√£o dispon√≠vel")
                    return resultado
                
                pg_data = db_manager.load_training_data(client_id)
                
                if not pg_data:
                    logging.info("‚ÑπÔ∏è Nenhum dado no PostgreSQL para sincronizar")
                    resultado["source_count"] = 0
                    resultado["success"] = True
                    return resultado
                
                resultado["source_count"] = len(pg_data)
                
                # Aplicar ao modelo Vanna
                for item in pg_data:
                    try:
                        tipo = item.get("training_data_type", "").lower()
                        conteudo = item.get("content", "").strip()
                        pergunta = item.get("question", "").strip()
                        
                        if not conteudo:
                            continue
                        
                        if tipo == "ddl":
                            self.vn.train(ddl=conteudo)
                            resultado["synced_count"] += 1
                        elif tipo == "sql" and pergunta:
                            self.vn.train(sql=conteudo, question=pergunta)
                            resultado["synced_count"] += 1
                        elif tipo == "documentation":
                            self.vn.train(documentation=conteudo)
                            resultado["synced_count"] += 1
                    
                    except Exception as e:
                        error_msg = f"Erro ao sincronizar item: {e}"
                        resultado["errors"].append(error_msg)
                        logging.error(f"‚ùå {error_msg}")
                
                resultado["success"] = resultado["synced_count"] > 0
                logging.info(f"‚úÖ {resultado['synced_count']} registros sincronizados: PostgreSQL ‚Üí Vanna")
            
            else:
                resultado["errors"].append(f"Dire√ß√£o inv√°lida: {direcao}")
            
            return resultado
            
        except Exception as e:
            logging.error(f"‚ùå Erro durante sincroniza√ß√£o: {e}")
            resultado["errors"].append(str(e))
            return resultado
    
    def comparar_dados(self, client_id=None):
        """
        Compara dados entre modelo Vanna e PostgreSQL
        
        Args:
            client_id (str): ID do cliente (para PostgreSQL)
        
        Returns:
            dict: Compara√ß√£o detalhada dos dados
        """
        logging.info("üîç Comparando dados entre Vanna e PostgreSQL...")
        
        resultado = {
            "success": False,
            "client_id": client_id,
            "vanna_count": 0,
            "postgresql_count": 0,
            "differences": {
                "only_in_vanna": 0,
                "only_in_postgresql": 0,
                "content_mismatch": 0
            },
            "details": []
        }
        
        try:
            # Dados do Vanna
            vanna_data = self.vn.get_training_data()
            if vanna_data is not None and not vanna_data.empty:
                resultado["vanna_count"] = len(vanna_data)
                vanna_items = vanna_data.to_dict(orient="records")
            else:
                vanna_items = []
            
            # Dados do PostgreSQL
            if DB_AVAILABLE:
                pg_data = db_manager.load_training_data(client_id)
                resultado["postgresql_count"] = len(pg_data) if pg_data else 0
                pg_items = pg_data or []
            else:
                resultado["details"].append("PostgreSQL n√£o dispon√≠vel para compara√ß√£o")
                pg_items = []
            
            # Criar √≠ndices para compara√ß√£o
            vanna_index = {
                item.get('id', f"temp_{i}"): item 
                for i, item in enumerate(vanna_items)
            }
            
            pg_index = {
                item.get('id', f"temp_{i}"): item 
                for i, item in enumerate(pg_items)
            }
            
            # Analisar diferen√ßas
            vanna_ids = set(vanna_index.keys())
            pg_ids = set(pg_index.keys())
            
            # IDs √∫nicos em cada fonte
            only_vanna = vanna_ids - pg_ids
            only_pg = pg_ids - vanna_ids
            common_ids = vanna_ids & pg_ids
            
            resultado["differences"]["only_in_vanna"] = len(only_vanna)
            resultado["differences"]["only_in_postgresql"] = len(only_pg)
            
            # Verificar diferen√ßas de conte√∫do nos IDs comuns
            content_mismatches = 0
            for common_id in common_ids:
                vanna_item = vanna_index[common_id]
                pg_item = pg_index[common_id]
                
                # Comparar campos principais
                vanna_content = vanna_item.get("content", "").strip()
                pg_content = pg_item.get("content", "").strip()
                
                if vanna_content != pg_content:
                    content_mismatches += 1
            
            resultado["differences"]["content_mismatch"] = content_mismatches
            
            # Adicionar detalhes
            if only_vanna:
                resultado["details"].append(f"{len(only_vanna)} itens apenas no Vanna")
            if only_pg:
                resultado["details"].append(f"{len(only_pg)} itens apenas no PostgreSQL")
            if content_mismatches:
                resultado["details"].append(f"{content_mismatches} itens com conte√∫do diferente")
            
            if not any(resultado["differences"].values()):
                resultado["details"].append("‚úÖ Dados sincronizados entre Vanna e PostgreSQL")
            
            resultado["success"] = True
            
            logging.info(f"üìä Compara√ß√£o conclu√≠da:")
            logging.info(f"   Vanna: {resultado['vanna_count']} registros")
            logging.info(f"   PostgreSQL: {resultado['postgresql_count']} registros")
            logging.info(f"   Diferen√ßas: {sum(resultado['differences'].values())}")
            
            return resultado
            
        except Exception as e:
            logging.error(f"‚ùå Erro durante compara√ß√£o: {e}")
            resultado["details"].append(f"Erro: {str(e)}")
            return resultado

def main():
    """Fun√ß√£o principal para uso via linha de comando"""
    import argparse
    
    parser = argparse.ArgumentParser(
        description="Controlador de Training Data do Vanna - Backup, Remo√ß√£o e Restaura√ß√£o",
        epilog="""
EXEMPLOS DE USO:
  %(prog)s list                                    # Listar dados atuais
  %(prog)s backup --backup-type both              # Backup completo (JSON + PostgreSQL)
  %(prog)s backup --client-id cli01 --backup-type postgresql  # Backup PostgreSQL espec√≠fico
  %(prog)s remove --confirm                        # Remover TODOS os dados (CUIDADO!)
  %(prog)s restore --client-id cli01              # Restaurar do PostgreSQL
  %(prog)s restore --backup-path backups/backup.json         # Restaurar de JSON
  %(prog)s list-backups                           # Listar backups dispon√≠veis

CONFIGURA√á√ÉO:
  Crie arquivo .env com: API_KEY, DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    parser.add_argument("action", choices=["list", "backup", "remove", "restore", "list-backups", "status", "sync", "compare"],
                       help="A√ß√£o a ser executada")
    parser.add_argument("--client-id", help="ID do cliente (opcional)")
    parser.add_argument("--backup-type", choices=["json", "postgresql", "both"], 
                       default="both", help="Tipo de backup (padr√£o: both)")
    parser.add_argument("--backup-path", help="Caminho para arquivo de backup JSON")
    parser.add_argument("--confirm", action="store_true", 
                       help="Confirmar opera√ß√µes perigosas (obrigat√≥rio para remove)")
    parser.add_argument("--details", action="store_true",
                       help="Mostrar detalhes extras na listagem")
    parser.add_argument("--verbose", "-v", action="store_true",
                       help="Modo verboso com logs detalhados")
    parser.add_argument("--direction", choices=["vanna_to_postgresql", "postgresql_to_vanna"],
                       default="vanna_to_postgresql", help="Dire√ß√£o da sincroniza√ß√£o")
    
    args = parser.parse_args()
    
    # Configurar n√≠vel de log baseado em verbose
    if args.verbose:
        logging.getLogger().setLevel(logging.DEBUG)
        logging.info("üîç Modo verboso ativado")
    
    try:
        controller = VannaTrainingController()
        
        if args.action == "list":
            controller.listar_training_data(show_details=args.details)
        
        elif args.action == "backup":
            print(f"\nüíæ Iniciando backup (tipo: {args.backup_type}, cliente: {args.client_id or 'global'})...")
            resultado = controller.realizar_backup(args.client_id, args.backup_type)
            
            print(f"\nüìä RESULTADO DO BACKUP:")
            print(f"   ‚úÖ Sucesso: {resultado['success']}")
            print(f"   üìã Registros: {resultado['records_count']}")
            print(f"   üïê Timestamp: {resultado['timestamp']}")
            if resultado['json_path']:
                print(f"   üìÑ Arquivo JSON: {resultado['json_path']}")
            print(f"   üóÑÔ∏è PostgreSQL: {'‚úÖ Sucesso' if resultado['postgresql_success'] else '‚ùå Falha'}")
            if resultado['errors']:
                print(f"   ‚ùå Erros: {'; '.join(resultado['errors'])}")
            
            print(f"\nüìã RESUMO:")
            print(f"   ‚Ä¢ Backup Type: {resultado['backup_type']}")
            print(f"   ‚Ä¢ Client ID: {resultado['client_id'] or 'Global'}")
            print(f"   ‚Ä¢ Records: {resultado['records_count']}")
        
        elif args.action == "remove":
            if not args.confirm:
                print("‚ùå ERRO: Opera√ß√£o 'remove' requer --confirm para seguran√ßa")
                print("   Esta opera√ß√£o remove TODOS os dados de treinamento do modelo!")
                print("   Use: python vanna_training_controller.py remove --confirm")
                sys.exit(1)
            
            print("\nüóëÔ∏è ATEN√á√ÉO: Removendo TODOS os dados de treinamento...")
            resultado = controller.remover_todos_training_data(args.confirm)
            
            print(f"\nüóëÔ∏è RESULTADO DA REMO√á√ÉO:")
            print(f"   ‚úÖ Sucesso: {resultado['success']}")
            print(f"   üìã Encontrados: {resultado.get('total_found', 0)}")
            print(f"   ‚úÖ Removidos: {resultado.get('removed_count', 0)}")
            print(f"   ‚ùå Falharam: {resultado.get('failed_count', 0)}")
            if resultado.get('errors'):
                print(f"   ‚ö†Ô∏è Erros: {len(resultado['errors'])} erros ocorreram")
        
        elif args.action == "restore":
            if not args.backup_path and not args.client_id:
                print("‚ùå ERRO: Especifique --backup-path (para JSON) ou --client-id (para PostgreSQL)")
                sys.exit(1)
            
            source = args.backup_path if args.backup_path else f"PostgreSQL (cliente: {args.client_id})"
            print(f"\nüîÑ Restaurando dados de: {source}")
            
            resultado = controller.restaurar_backup(args.backup_path, args.client_id)
            
            print(f"\nüîÑ RESULTADO DA RESTAURA√á√ÉO:")
            print(f"   ‚úÖ Sucesso: {resultado['success']}")
            print(f"   üìã Carregados: {resultado['records_loaded']}")
            print(f"   üéØ Treinados: {resultado['trained_count']}")
            print(f"   üìç Fonte: {resultado['source']}")
            if resultado.get('errors'):
                print(f"   ‚ö†Ô∏è Erros: {len(resultado['errors'])} erros durante treinamento")
        
        elif args.action == "list-backups":
            backups = controller.listar_backups()
            
            print(f"\nüìÅ BACKUPS DISPON√çVEIS:")
            
            print(f"\nüìÑ BACKUPS JSON ({len(backups['json_backups'])} arquivos):")
            if backups['json_backups']:
                for backup in sorted(backups['json_backups'], key=lambda x: x['modified'], reverse=True):
                    print(f"   ‚Ä¢ {backup['filename']}")
                    print(f"     üìè Tamanho: {backup['size_mb']} MB")
                    print(f"     üïê Modificado: {backup['modified']}")
                    print(f"     ÔøΩ Path: {backup['path']}")
                    print()
            else:
                print("   Nenhum backup JSON encontrado")
            
            print(f"\nüóÑÔ∏è BACKUPS POSTGRESQL ({len(backups['postgresql_clients'])} clientes):")
            if backups['postgresql_clients']:
                for client in sorted(backups['postgresql_clients']):
                    print(f"   ‚Ä¢ Cliente: {client}")
            else:
                print("   Nenhum backup PostgreSQL encontrado")
        
        elif args.action == "status":
            # Nova funcionalidade: status detalhado
            print("\nüìä STATUS DO SISTEMA:")
            
            # Status do modelo Vanna
            training_data = controller.listar_training_data(show_details=False)
            if training_data is not None:
                print(f"   üéØ Modelo Vanna: {len(training_data)} registros")
            else:
                print("   üéØ Modelo Vanna: Vazio")
            
            # Status PostgreSQL
            if DB_AVAILABLE:
                try:
                    pg_ids = db_manager.get_training_data_ids(None)
                    print(f"   üóÑÔ∏è PostgreSQL: {len(pg_ids)} registros")
                except:
                    print("   üóÑÔ∏è PostgreSQL: Erro de conex√£o")
            else:
                print("   üóÑÔ∏è PostgreSQL: N√£o dispon√≠vel")
            
            # Status backups JSON
            backups = controller.listar_backups()
            print(f"   üìÑ Backups JSON: {len(backups['json_backups'])} arquivos")
            
            # Configura√ß√µes
            print(f"\n‚öôÔ∏è CONFIGURA√á√ïES:")
            print(f"   ‚Ä¢ API Key: {'‚úÖ Configurada' if controller.api_key else '‚ùå Faltando'}")
            print(f"   ‚Ä¢ DB Host: {controller.db_config.get('host', 'N/A')}")
            print(f"   ‚Ä¢ DB Name: {controller.db_config.get('dbname', 'N/A')}")
            print(f"   ‚Ä¢ Backup Dir: {controller.backup_dir}")
        
        elif args.action == "sync":
            print(f"\nüîÑ Sincronizando dados ({args.direction})...")
            resultado = controller.sincronizar_dados(args.direction, args.client_id)
            
            print(f"\nüîÑ RESULTADO DA SINCRONIZA√á√ÉO:")
            print(f"   ‚úÖ Sucesso: {resultado['success']}")
            print(f"   üìç Dire√ß√£o: {resultado['direction']}")
            print(f"   üìã Origem: {resultado['source_count']} registros")
            print(f"   üéØ Sincronizados: {resultado['synced_count']} registros")
            print(f"   üë§ Cliente: {resultado['client_id'] or 'Global'}")
            if resultado.get('errors'):
                print(f"   ‚ùå Erros: {'; '.join(resultado['errors'])}")
        
        elif args.action == "compare":
            print(f"\nüîç Comparando dados (Cliente: {args.client_id or 'Global'})...")
            resultado = controller.comparar_dados(args.client_id)
            
            print(f"\nüîç RESULTADO DA COMPARA√á√ÉO:")
            print(f"   ‚úÖ Sucesso: {resultado['success']}")
            print(f"   üéØ Vanna: {resultado['vanna_count']} registros")
            print(f"   üóÑÔ∏è PostgreSQL: {resultado['postgresql_count']} registros")
            print(f"   üë§ Cliente: {resultado['client_id'] or 'Global'}")
            
            print(f"\nüìä DIFEREN√áAS ENCONTRADAS:")
            diffs = resultado['differences']
            print(f"   ‚Ä¢ Apenas no Vanna: {diffs['only_in_vanna']}")
            print(f"   ‚Ä¢ Apenas no PostgreSQL: {diffs['only_in_postgresql']}")
            print(f"   ‚Ä¢ Conte√∫do divergente: {diffs['content_mismatch']}")
            
            if resultado.get('details'):
                print(f"\nüìã DETALHES:")
                for detail in resultado['details']:
                    print(f"   ‚Ä¢ {detail}")
    
    except KeyboardInterrupt:
        print("\n‚èπÔ∏è Opera√ß√£o cancelada pelo usu√°rio")
        sys.exit(1)
    except Exception as e:
        logging.error(f"‚ùå Erro na execu√ß√£o: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)

if __name__ == "__main__":
    main()
